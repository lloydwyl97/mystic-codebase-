# train_fast_mutations.py
"""
Mutation Trainer - Fast Strategy Evolution System
Continuously trains and evolves trading strategies using backtesting.
Built for Windows 11 Home + PowerShell + Docker.
"""

import os
import random
import time
import logging
import json
from typing import Dict, Any, List
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configuration
STRATEGY_DIR = "./generated_modules"
HIST_DATA = "./data/ohlcv/"
TRAIN_INTERVAL = 1800
MAX_STRATEGIES = 50


def list_strategies() -> List[str]:
    """List available strategy files."""
    try:
        if not os.path.exists(STRATEGY_DIR):
            os.makedirs(STRATEGY_DIR, exist_ok=True)
            return []

        strategy_files = [f for f in os.listdir(STRATEGY_DIR) if f.endswith(".py")]
        return strategy_files
    except Exception as e:
        logger.error(f"❌ Error listing strategies: {e}")
        return []


def simulate_backtest(strategy_file: str) -> Dict[str, Any]:
    """Run real backtesting of a strategy using live historical data from Binance."""
    try:
        import pandas as pd
        import importlib.util
        import requests

        # Fetch historical price data
        symbol = "BTCUSDT"
        url = f"https://api.binance.us/api/v3/klines?symbol={symbol}&interval=1h&limit=500"
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        klines = response.json()
        closes = [float(k[4]) for k in klines]
        df = pd.DataFrame({"close": closes})
        # Dynamically import the strategy
        strategy_path = os.path.join(STRATEGY_DIR, strategy_file)
        spec = importlib.util.spec_from_file_location("strategy_mod", strategy_path)
        strategy_mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(strategy_mod)
        # Run the strategy function if present
        if hasattr(strategy_mod, "rsi_strategy"):
            df = strategy_mod.rsi_strategy(df)
        # Calculate winrate and profit
        trades = df["signal"].diff().fillna(0)
        buy_signals = trades[trades == 1].index
        sell_signals = trades[trades == -1].index
        profit_loss = 0
        for buy, sell in zip(buy_signals, sell_signals):
            profit_loss += df["close"][sell] - df["close"][buy]
        winrate = len(buy_signals) / max(len(trades), 1)
        result = {
            "strategy": strategy_file,
            "winrate": winrate,
            "total_trades": len(buy_signals),
            "profit_loss": profit_loss,
            "sharpe_ratio": 0,  # Placeholder, can be calculated with returns
            "timestamp": datetime.timezone.utcnow().isoformat(),
        }
        logger.info(
            f"Backtest: {strategy_file} - Winrate: {winrate:.1%}, P&L: {profit_loss:.1f}, Trades: {len(buy_signals)}"
        )
        return result
    except Exception as e:
        logger.error(f"Error backtesting {strategy_file}: {e}")
        return {
            "strategy": strategy_file,
            "error": str(e),
            "timestamp": datetime.timezone.utcnow().isoformat(),
        }


def save_backtest_result(result: Dict[str, Any]) -> None:
    """Save backtest result to file."""
    try:
        results_dir = "/data/backtest_results"
        os.makedirs(results_dir, exist_ok=True)

        filename = f"backtest_{result['strategy'].replace('.py', '')}_{int(time.time())}.json"
        filepath = os.path.join(results_dir, filename)

        with open(filepath, "w") as f:
            json.dump(result, f, indent=2)

        logger.info(f"💾 Saved backtest result: {filename}")

    except Exception as e:
        logger.error(f"❌ Error saving backtest result: {e}")


def initialize_live_strategy_training() -> None:
    """Initialize live strategy training without sample data."""
    try:
        if os.path.exists(STRATEGY_DIR) and os.listdir(STRATEGY_DIR):
            logger.info("📂 Strategy directory already exists - ready for live training")
            return

        # Create strategy directory for live strategies
        os.makedirs(STRATEGY_DIR, exist_ok=True)

        # Create a placeholder file to indicate live training is ready
        placeholder_file = os.path.join(STRATEGY_DIR, "LIVE_TRAINING_READY.txt")
        with open(placeholder_file, "w") as f:
            f.write("Live strategy training initialized\n")
            f.write("Strategies will be generated by AI mutation system\n")
            f.write(f"Initialized: {datetime.timezone.utcnow().isoformat()}\n")

        logger.info("📂 Initialized strategy directory for live AI training")
        logger.info("   Note: Strategies will be generated by AI mutation system")

    except Exception as e:
        logger.error(f"❌ Error initializing live strategy training: {e}")


def run_training_cycle() -> Dict[str, Any]:
    """Run a complete training cycle."""
    try:
        strategies = list_strategies()

        if not strategies:
            logger.info("📂 No strategies found for training")
            return {"trained": 0, "total": 0}

        # Limit number of strategies to train per cycle
        if len(strategies) > MAX_STRATEGIES:
            strategies = random.sample(strategies, MAX_STRATEGIES)

        logger.info(f"🚀 Starting training cycle for {len(strategies)} strategies")

        results = []
        for strategy_file in strategies:
            result = simulate_backtest(strategy_file)
            results.append(result)
            save_backtest_result(result)

            # Small delay between backtests
            time.sleep(1)

        # Save training summary
        summary = {
            "cycle_timestamp": datetime.timezone.utcnow().isoformat(),
            "strategies_trained": len(strategies),
            "results": results,
        }

        try:
            with open("/data/training_summary.json", "w") as f:
                json.dump(summary, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving training summary: {e}")

        logger.info(f"✅ Training cycle complete: {len(strategies)} strategies processed")

        return {"trained": len(strategies), "total": len(strategies)}

    except Exception as e:
        logger.error(f"❌ Error in training cycle: {e}")
        return {"trained": 0, "total": 0, "error": str(e)}


def main():
    """Main loop for continuous strategy training."""
    logger.info("🚀 Mutation Trainer starting...")

    # Initialize live strategy training
    initialize_live_strategy_training()

    while True:
        try:
            run_training_cycle()

            # Create ping file for dashboard
            with open("/tmp/train_fast_mutations.ping", "w") as f:
                f.write(str(time.time()))

            logger.info(f"⏰ Next training cycle in {TRAIN_INTERVAL} seconds")
            time.sleep(TRAIN_INTERVAL)

        except KeyboardInterrupt:
            logger.info("🛑 Mutation Trainer stopped")
            break
        except Exception as e:
            logger.error(f"❌ Main loop error: {e}")
            time.sleep(60)  # Wait 1 minute before retrying


if __name__ == "__main__":
    main()
