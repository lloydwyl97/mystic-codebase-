import datetime
import os

from ai_mutation_feedback import fetch_recent_strategy_stats


class SelfWriter:
    """Autonomous code generation engine"""

    def __init__(self):
        self.generated_modules = []
        self.mutation_count = 0
        os.makedirs("generated_modules", exist_ok=True)

    def generate_module_blueprint(self, strategy_stats):
        """Generate a new module based on winning strategy patterns"""
        if not strategy_stats:
            return None, None

        # Pick the best performing strategy as template
        top = max(strategy_stats, key=lambda s: s.get("total_profit", 0))
        name = top.get("strategy", "UnknownStrategy")

        # Generate timestamp for uniqueness
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")

        # Create evolved module name
        evolved_name = f"{name}_evolved_{timestamp}"

        # Generate autonomous code
        code = self._generate_autonomous_code(evolved_name, top)

        return evolved_name + ".py", code

    def _generate_autonomous_code(self, module_name, strategy_data):
        """Generate autonomous Python code"""
        win_rate = strategy_data.get("win_rate", 0.5)
        total_profit = strategy_data.get("total_profit", 0)

        code = f'''#!/usr/bin/env python3
"""
Auto-generated module: {module_name}
Generated by AI Self-Writer
Win Rate: {win_rate:.2%}
Total Profit: ${total_profit:.2f}
"""

import time
import random
from datetime import datetime

class {module_name.replace('.', '_')}:
    """Autonomous trading agent generated by AI"""

    def __init__(self):
        self.name = "{module_name}"
        self.win_rate = {win_rate}
        self.total_profit = {total_profit}
        self.generation_time = "{datetime.datetime.now().isoformat()}"
        self.mutation_count = {self.mutation_count}

    def execute_strategy(self):
        """Execute the evolved trading strategy"""
        print(f"[{module_name}] Executing evolved strategy...")

        # Autonomous decision making
        decision = self._make_decision()

        # Execute trade logic
        result = self._execute_trade(decision)

        print(f"[{module_name}] Strategy completed: {{result}}")
        return result

    def _make_decision(self):
        """Make autonomous trading decision"""
        # Evolved decision logic based on win rate
        if self.win_rate > 0.6:
            return "aggressive_buy"
        elif self.win_rate > 0.4:
            return "conservative_buy"
        else:
            return "wait"

    def _execute_trade(self, decision):
        """Execute the trading decision"""
        if decision == "aggressive_buy":
            return "{{'action': 'buy', 'size': 'large', 'confidence': 0.9}}"
        elif decision == "conservative_buy":
            return "{{'action': 'buy', 'size': 'small', 'confidence': 0.6}}"
        else:
            return "{{'action': 'hold', 'reason': 'low_confidence'}}"

    def mutate(self):
        """Self-mutate the strategy"""
        print(f"[{module_name}] Beginning self-mutation...")

        # Random mutation parameters
        mutation_factor = random.uniform(0.8, 1.2)
        self.win_rate *= mutation_factor
        self.win_rate = max(0.0, min(1.0, self.win_rate))

        print(f"[{module_name}] Mutated win rate to {{self.win_rate:.2%}}")
        return self

    def get_status(self):
        """Get current status"""
        return {{
            "name": self.name,
            "win_rate": self.win_rate,
            "total_profit": self.total_profit,
            "generation_time": self.generation_time,
            "mutation_count": self.mutation_count
        }}

def run():
    """Main execution function"""
    agent = {module_name.replace('.', '_')}()
    result = agent.execute_strategy()
    return result

if __name__ == "__main__":
    run()
'''
        return code

    def save_module(self, file_name, code):
        """Save generated module to disk"""
        full_path = os.path.join("generated_modules", file_name)

        with open(full_path, "w") as f:
            f.write(code)

        self.generated_modules.append(full_path)
        print(f"[SELF-WRITER] New module saved â†’ {full_path}")
        return full_path

    def auto_write_loop(self):
        """Main autonomous writing loop"""
        print("[SELF-WRITER] Starting autonomous code generation...")

        # Get strategy performance data
        stats = fetch_recent_strategy_stats(hours_back=12)

        if not stats:
            print("[SELF-WRITER] No strategy data available for mutation.")
            return None

        # Generate new module
        file_name, code = self.generate_module_blueprint(stats)

        if file_name and code:
            # Save the module
            path = self.save_module(file_name, code)

            # Increment mutation counter
            self.mutation_count += 1

            print(f"[SELF-WRITER] Generated module {self.mutation_count}: {file_name}")
            return path

        return None

    def get_generation_stats(self):
        """Get statistics about generated modules"""
        return {
            "total_modules": len(self.generated_modules),
            "mutation_count": self.mutation_count,
            "latest_modules": (self.generated_modules[-5:] if self.generated_modules else []),
        }


def auto_write_loop():
    """Simple function interface for external calls"""
    writer = SelfWriter()
    return writer.auto_write_loop()


if __name__ == "__main__":
    # Test autonomous writing
    path = auto_write_loop()
    if path:
        print(f"[SELF-WRITER] Successfully generated: {path}")
    else:
        print("[SELF-WRITER] No module generated")


