"""
🔬 ADVANCED TECH HUB - Quantum Computing, Phase 5 Monitoring, Blockchain, Mining, Experimental Services
Comprehensive advanced technology monitoring and control center
"""

import streamlit as st
import plotly.express as px
import numpy as np

# Import our modular components
from streamlit.data_client import fetch_api as _fetch_api, post_api as _post_api  # type: ignore[attr-defined]
from streamlit.ui_guard import display_guard
from streamlit.pages.components.common_utils import (
    render_page_header,
    render_metrics_grid,
    format_currency,
    format_percentage,
)
from streamlit.pages.components.responsive_layout import (
    responsive_columns,
)

# Import the real, full-featured advanced tech page functions
from ..pages.advanced_tech.phase5_monitoring import render_phase5_monitoring_page
from ..pages.advanced_tech.quantum_computing import render_quantum_computing_page
from ..pages.advanced_tech.blockchain import render_blockchain_page
from ..pages.advanced_tech.mining_operations import render_mining_operations_page
from ..pages.advanced_tech.experimental_services import (
    render_experimental_services_page,
)
from streamlit.api_client import api_client

# Backup: create a .bak_cursor copy once
try:
    import shutil
    from pathlib import Path
    _p = Path(__file__)
    _bak = _p.with_suffix(_p.suffix + ".bak_cursor")
    if not _bak.exists():
        shutil.copyfile(_p, _bak)
except Exception:
    pass


def render_advanced_tech_hub():
    """Render the complete Advanced Tech Hub with all cutting-edge functionality"""

    # Page header
    render_page_header(
        "🔬 Advanced Tech Hub",
        "Quantum Computing, Phase 5 Monitoring, Blockchain, Mining & Experimental Services",
    )

    # Fetch advanced tech data
    with display_guard("Advanced Tech Data"):
        phase5_data = _fetch_api("/api/phase5/metrics")
        quantum_data = _fetch_api("/api/quantum/systems")
        blockchain_data = _fetch_api("/api/blockchain/status")
        mining_data = _fetch_api("/api/mining/status")
        experimental_data = _fetch_api("/api/experimental/status")

    # Check data availability
    has_data = any(
        [
            phase5_data,
            quantum_data,
            blockchain_data,
            mining_data,
            experimental_data,
        ]
    )
    data_source = "api" if has_data else "fallback"

    # Status indicators
    col_status1, col_status2 = responsive_columns(2)
    with col_status1:
        if data_source != "fallback":
            st.success(f"🟢 Advanced Tech Connected - Source: {data_source.upper()}")
        else:
            st.warning("⚠️ Using fallback data - Advanced Tech APIs unavailable")

    with col_status2:
        # Overall system status
        active_systems = 0
        total_systems = 0

        if phase5_data and phase5_data.get("data"):
            total_systems += 1
            if phase5_data.get("data", {}).get("status") == "active":
                active_systems += 1

        if quantum_data and quantum_data.get("data"):
            quantum_systems = quantum_data.get("data", [])
            total_systems += len(quantum_systems)
            active_systems += len(
                [q for q in quantum_systems if q.get("status") == "Online"]
            )

        if blockchain_data and blockchain_data.get("data"):
            total_systems += 1
            if blockchain_data.get("data", {}).get("status") == "active":
                active_systems += 1

        if mining_data and mining_data.get("data"):
            total_systems += 1
            if mining_data.get("data", {}).get("status") == "active":
                active_systems += 1

        if experimental_data and experimental_data.get("data"):
            total_systems += 1
            if experimental_data.get("data", {}).get("status") == "active":
                active_systems += 1

        st.info(f"Advanced Systems: {active_systems}/{total_systems} Active")

    # Advanced Tech Overview Metrics
    st.subheader("📊 Advanced Tech Overview")

    # Create comprehensive metrics for all advanced systems
    advanced_metrics = []

    # Phase 5 Metrics
    if phase5_data and phase5_data.get("data"):
        phase5_metrics = phase5_data.get("data", {})
        advanced_metrics.extend(
            [
                {
                    "label": "🧠 Neuro-Sync",
                    "value": phase5_metrics.get("neuro_sync", "0%"),
                    "delta": phase5_metrics.get("neuro_sync_change", "+0%"),
                },
                {
                    "label": "🌌 Cosmic Signal",
                    "value": phase5_metrics.get("cosmic_signal", "0%"),
                    "delta": phase5_metrics.get("cosmic_signal_change", "+0%"),
                },
                {
                    "label": "✨ Aura Alignment",
                    "value": phase5_metrics.get("aura_alignment", "0%"),
                    "delta": phase5_metrics.get("aura_alignment_change", "+0%"),
                },
                {
                    "label": "🌀 Interdim Activity",
                    "value": phase5_metrics.get("interdim_activity", "0%"),
                    "delta": phase5_metrics.get("interdim_activity_change", "+0%"),
                },
            ]
        )

    # Quantum Metrics
    if quantum_data and quantum_data.get("data"):
        quantum_systems = quantum_data.get("data", [])
        online_quantum = len(
            [q for q in quantum_systems if q.get("status") == "Online"]
        )
        total_qubits = sum([q.get("qubits", 0) for q in quantum_systems])
        avg_error_rate = np.mean(
            [q.get("error_rate", 0) for q in quantum_systems if q.get("error_rate")]
        )

        advanced_metrics.extend(
            [
                {
                    "label": "⚛️ Quantum Systems",
                    "value": f"{online_quantum}/{len(quantum_systems)}",
                    "delta": None,
                },
                {
                    "label": "🔢 Total Qubits",
                    "value": str(total_qubits),
                    "delta": None,
                },
                {
                    "label": "📉 Avg Error Rate",
                    "value": f"{avg_error_rate:.2f}%",
                    "delta": None,
                },
            ]
        )

    # Blockchain Metrics
    if blockchain_data and blockchain_data.get("data"):
        blockchain_status = blockchain_data.get("data", {})
        advanced_metrics.extend(
            [
                {
                    "label": "🔗 Blockchain Health",
                    "value": blockchain_status.get("health", "Unknown"),
                    "delta": None,
                },
                {
                    "label": "⛓️ Block Height",
                    "value": str(blockchain_status.get("block_height", 0)),
                    "delta": None,
                },
                {
                    "label": "⚡ Hash Rate",
                    "value": (f"{blockchain_status.get('hash_rate', 0):.1f} TH/s"),
                    "delta": None,
                },
            ]
        )

    # Mining Metrics
    if mining_data and mining_data.get("data"):
        mining_status = mining_data.get("data", {})
        advanced_metrics.extend(
            [
                {
                    "label": "⛏️ Active Miners",
                    "value": str(mining_status.get("active_miners", 0)),
                    "delta": None,
                },
                {
                    "label": "💰 Mining Revenue",
                    "value": format_currency(mining_status.get("daily_revenue", 0)),
                    "delta": format_percentage(
                        mining_status.get("revenue_change_24h", 0)
                    ),
                },
                {
                    "label": "⚡ Total Hash Rate",
                    "value": (f"{mining_status.get('total_hashrate', 0):.1f} TH/s"),
                    "delta": None,
                },
            ]
        )

    # Experimental Metrics
    if experimental_data and experimental_data.get("data"):
        experimental_status = experimental_data.get("data", {})
        advanced_metrics.extend(
            [
                {
                    "label": "🧪 Experimental Status",
                    "value": (
                        "🟢 Active"
                        if experimental_status.get("status") == "active"
                        else "🔴 Inactive"
                    ),
                    "delta": None,
                },
                {
                    "label": "🔬 Active Experiments",
                    "value": str(experimental_status.get("active_experiments", 0)),
                    "delta": None,
                },
            ]
        )

    # Render metrics in responsive grid
    if advanced_metrics:
        render_metrics_grid(advanced_metrics, cols=4)
    else:
        st.info("No advanced tech metrics available")

    # Enhanced Navigation Tabs
    st.subheader("🎯 Advanced Technology Operations")

    # Create comprehensive tabs for all advanced tech functionality
    (
        tab_phase5,
        tab_quantum,
        tab_blockchain,
        tab_mining,
        tab_experimental,
        tab_integration,
    ) = st.tabs(
        [
            "🔬 Phase 5",
            "⚛️ Quantum",
            "🔗 Blockchain",
            "⛏️ Mining",
            "🧪 Experimental",
            "🔗 Integration",
        ]
    )

    # Tab 1: Phase 5 Monitoring
    with tab_phase5:
        render_phase5_monitoring_page()

    # Tab 2: Quantum Computing
    with tab_quantum:
        render_quantum_computing_page()

    # Tab 3: Blockchain
    with tab_blockchain:
        render_blockchain_page()

    # Tab 4: Mining Operations
    with tab_mining:
        render_mining_operations_page()

    # Tab 5: Experimental Services
    with tab_experimental:
        render_experimental_services_page()

    # Tab 6: System Integration
    with tab_integration:
        render_system_integration_section(
            phase5_data,
            quantum_data,
            blockchain_data,
            mining_data,
            experimental_data,
        )

    # Advanced Controls Panel
    st.subheader("🎛️ Advanced System Controls")

    col_controls1, col_controls2, col_controls3, col_controls4 = responsive_columns(4)

    with col_controls1:
        if st.button("🔬 Phase 5 Reset", type="secondary", use_container_width=True):
            reset_result = _post_api("/api/phase5/reset", {})
            if reset_result:
                st.success("Phase 5 system reset!")
            else:
                st.error("Failed to reset Phase 5")

    with col_controls2:
        if st.button("⚛️ Quantum Calibrate", type="secondary", use_container_width=True):
            calibrate_result = _post_api("/api/quantum/calibrate", {})
            if calibrate_result:
                st.success("Quantum systems calibrated!")
            else:
                st.error("Failed to calibrate quantum systems")

    with col_controls3:
        if st.button("🔗 Blockchain Sync", type="secondary", use_container_width=True):
            sync_result = _post_api("/api/blockchain/sync", {})
            if sync_result:
                st.success("Blockchain synchronized!")
            else:
                st.error("Failed to sync blockchain")

    with col_controls4:
        if st.button("⛏️ Mining Restart", type="secondary", use_container_width=True):
            restart_result = _post_api("/api/mining/restart", {})
            if restart_result:
                st.success("Mining operations restarted!")
            else:
                st.error("Failed to restart mining")

    # Advanced Configuration
    st.subheader("⚙️ Advanced Configuration")

    col_config1, col_config2 = responsive_columns(2)

    with col_config1:
        st.subheader("Phase 5 Settings")

        # Phase 5 configuration
        phase5_sensitivity = st.slider(
            "Phase 5 Sensitivity",
            min_value=1,
            max_value=10,
            value=5,
            help="Adjust Phase 5 monitoring sensitivity",
        )

        phase5_frequency = st.selectbox(
            "Phase 5 Update Frequency",
            ["1 second", "5 seconds", "10 seconds", "30 seconds", "1 minute"],
            index=2,
            help="How often to update Phase 5 metrics",
        )

        phase5_alerts = st.checkbox(
            "Enable Phase 5 Alerts",
            value=True,
            help="Enable real-time Phase 5 alerts",
        )

    with col_config2:
        st.subheader("Quantum Settings")

        # Quantum configuration
        quantum_error_threshold = st.slider(
            "Quantum Error Threshold (%)",
            min_value=0.1,
            max_value=5.0,
            value=1.0,
            step=0.1,
            help="Maximum acceptable quantum error rate",
        )

        quantum_job_priority = st.selectbox(
            "Quantum Job Priority",
            ["Low", "Medium", "High", "Critical"],
            index=1,
            help="Default priority for quantum jobs",
        )

        quantum_auto_optimize = st.checkbox(
            "Auto-optimize Quantum",
            value=True,
            help="Automatically optimize quantum parameters",
        )

    # Save advanced configuration
    if st.button(
        "💾 Save Advanced Configuration",
        type="primary",
        use_container_width=True,
    ):
        # Prepare advanced configuration
        advanced_config = {
            "phase5": {
                "sensitivity": phase5_sensitivity,
                "frequency": phase5_frequency,
                "alerts_enabled": phase5_alerts,
            },
            "quantum": {
                "error_threshold": quantum_error_threshold,
                "job_priority": quantum_job_priority,
                "auto_optimize": quantum_auto_optimize,
            },
        }

        # Save configuration
        config_result = api_client.post_api_data(
            "/api/advanced-tech/config", advanced_config
        )
        if config_result:
            st.success("Advanced configuration saved successfully!")
        else:
            st.error("Failed to save advanced configuration")

    # Real-time Advanced Tech Events
    st.subheader("📡 Real-time Advanced Tech Events")

    # Get advanced tech events
    events_data = _fetch_api("/api/advanced-tech/events")

    if events_data and events_data.get("data"):
        events = events_data.get("data", [])
        for event in events[:10]:  # Show last 10 events
            event_type = event.get("type", "info")
            event_message = event.get("message", "No message")
            event_timestamp = event.get("timestamp", "Unknown")
            event_source = event.get("source", "Advanced Tech")

            if event_type == "critical":
                st.error(f"🚨 [{event_source}] {event_message} ({event_timestamp})")
            elif event_type == "warning":
                st.warning(f"⚠️ [{event_source}] {event_message} ({event_timestamp})")
            elif event_type == "success":
                st.success(f"✅ [{event_source}] {event_message} ({event_timestamp})")
            else:
                st.info(f"ℹ️ [{event_source}] {event_message} ({event_timestamp})")
    else:
        st.info("No recent advanced tech events")

    # Advanced Tech Performance Analytics
    st.subheader("📊 Advanced Tech Performance Analytics")

    # Get performance data
    performance_data = _fetch_api("/api/advanced-tech/performance")

    if performance_data and performance_data.get("data"):
        perf_data = performance_data.get("data", {})

        col_perf1, col_perf2 = responsive_columns(2)

        with col_perf1:
            # Phase 5 Performance Chart
            if "phase5_performance" in perf_data:
                phase5_perf = perf_data["phase5_performance"]
                fig_phase5 = px.line(
                    x=phase5_perf.get("timestamps", []),
                    y=phase5_perf.get("values", []),
                    title="Phase 5 Performance Over Time",
                    labels={"x": "Time", "y": "Performance Score"},
                )
                fig_phase5.update_layout(height=300)
                st.plotly_chart(fig_phase5, use_container_width=True)

        with col_perf2:
            # Quantum Performance Chart
            if "quantum_performance" in perf_data:
                quantum_perf = perf_data["quantum_performance"]
                fig_quantum = px.bar(
                    x=quantum_perf.get("systems", []),
                    y=quantum_perf.get("accuracy", []),
                    title="Quantum System Accuracy",
                    labels={"x": "System", "y": "Accuracy (%)"},
                )
                fig_quantum.update_layout(height=300)
                st.plotly_chart(fig_quantum, use_container_width=True)
    else:
        st.info("No performance analytics available")


def render_system_integration_section(
    phase5_data, quantum_data, blockchain_data, mining_data, experimental_data
):
    """Render the system integration section showing how all advanced systems work together"""

    st.subheader("🔗 System Integration Overview")

    # Integration status

    # Display integration status
    col_int1, col_int2, col_int3, col_int4, col_int5 = responsive_columns(5)

    with col_int1:
        st.info("Phase 5 → Quantum")
        st.success("🟢 Connected")

    with col_int2:
        st.info("Quantum → Blockchain")
        st.success("🟢 Connected")

    with col_int3:
        st.info("Blockchain → Mining")
        st.success("🟢 Connected")

    with col_int4:
        st.info("Mining → Experimental")
        st.success("🟢 Connected")

    with col_int5:
        st.info("Experimental → Phase 5")
        st.success("🟢 Connected")

    # Integration flow diagram
    st.subheader("🔄 Integration Flow")

    # Create a simple flow diagram
    st.markdown(
        """
    ```
    Phase 5 Monitoring
         ↓
    Quantum Computing
         ↓
    Blockchain Operations
         ↓
    Mining Operations
         ↓
    Experimental Services
         ↓
    Phase 5 Monitoring (Feedback Loop)
    ```
    """
    )

    # Integration metrics
    st.subheader("📊 Integration Metrics")

    integration_metrics = [
        {"label": "Data Flow Rate", "value": "1.2 GB/s", "delta": "+5.3%"},
        {"label": "Integration Latency", "value": "2.3ms", "delta": "-12.1%"},
        {"label": "System Sync", "value": "99.8%", "delta": "+0.2%"},
        {"label": "Error Rate", "value": "0.02%", "delta": "-0.01%"},
    ]

    render_metrics_grid(integration_metrics, cols=4)

    # Integration controls
    st.subheader("🎛️ Integration Controls")

    col_int_controls1, col_int_controls2, col_int_controls3 = responsive_columns(3)

    with col_int_controls1:
        if st.button("🔄 Sync All Systems", type="primary", use_container_width=True):
            sync_result = api_client.post_api_data("/api/advanced-tech/sync-all", {})
            if sync_result:
                st.success("All systems synchronized!")
            else:
                st.error("Failed to sync systems")

    with col_int_controls2:
        if st.button("⚡ Optimize Flow", type="secondary", use_container_width=True):
            optimize_result = api_client.post_api_data(
                "/api/advanced-tech/optimize-flow", {}
            )
            if optimize_result:
                st.success("Data flow optimized!")
            else:
                st.error("Failed to optimize flow")

    with col_int_controls3:
        if st.button("🔍 Test Integration", type="secondary", use_container_width=True):
            test_result = api_client.post_api_data(
                "/api/advanced-tech/test-integration", {}
            )
            if test_result:
                st.success("Integration test completed!")
            else:
                st.error("Integration test failed")
